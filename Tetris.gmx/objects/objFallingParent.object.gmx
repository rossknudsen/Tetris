<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objFallingTileBase</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="9" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// rotates the object to the right.
  
if (!isFalling)
    exit;
    
var originalImageIndex = image_index;
image_index = scrIncrementSpriteImage(self, 1);

// check if there is an obstacle in the way preventing us from rotating.
if (place_meeting(x, y, objFallingParent)
    || place_meeting(x, y, objFloor)
    || place_meeting(x, y, objBrick))
{
    image_index = originalImageIndex;
    exit;
}

// if there is a wall in the way, we may be able to move to the left or right.
var wall = instance_place(x, y, objWall);
if (wall != noone)
{
    // keep the original position in case we have to revert to it.
    var originalX = x;
    
    // try to see if we can move the brick right or left to fit inside the walls.
    var tryDirection = 1;
    if (x &lt; wall.x)
        tryDirection = -1;
    
    // try up to 3 squares across.  The third try is only for objLong which could be
    // tested for to prevent weird movements for other brick types.
    var i;
    for (i = 1; i &lt;= 3; i++)
    {
        // try moving the brick sideways to the new position and if successful exit.
        x += i * tryDirection * brickSize;
        if (!place_meeting(x, y, all))
        {
            // we were able to rotate the piece so play woosh.
            audio_play_sound(sndWoosh, 10, false);
            exit;
        }
    }
    
    // otherwise revert all changes.
    x = originalX;
    image_index = originalImageIndex;
}
else
{
    // the piece is free to move so play woosh.
    audio_play_sound(sndWoosh, 10, false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="39">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle the right key from the user.

// if we aren't falling, then we can't move.
if (!isFalling)
    exit;
    
var xMovement = brickSize;

// check for impact with the wall.
var obstacle = instance_place(x + xMovement, y, all);
if (obstacle == noone)
{
    // move the brick to the left.
    x += xMovement;
}
// cannot move!!!
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// rotates the object to the left.

if (!isFalling)
    exit;

var originalImageIndex = image_index;
image_index = scrIncrementSpriteImage(self, 1);

// check if there is an obstacle in the way preventing us from rotating.
if (place_meeting(x, y, objFallingParent)
    || place_meeting(x, y, objFloor)
    || place_meeting(x, y, objBrick))
{
    image_index = originalImageIndex;
    exit;
}

// if there is a wall in the way, we may be able to move to the left or right.
var wall = instance_place(x, y, objWall);
if (wall != noone)
{
    // keep the original position in case we have to revert to it.
    var originalX = x;
    
    // try to see if we can move the brick right or left to fit inside the walls.
    var tryDirection = 1;
    if (x &lt; wall.x)
        tryDirection = -1;
    
    // try up to 3 squares across.  The third try is only for objLong which could be
    // tested for to prevent weird movements for other brick types.
    var i;
    for (i = 1; i &lt;= 3; i++)
    {
        // try moving the brick sideways to the new position and if successful exit.
        x += i * tryDirection * brickSize;
        if (!place_meeting(x, y, all))
        {
            // we were able to rotate the piece so play woosh.
            audio_play_sound(sndWoosh, 10, false);
            exit;
        }
    }
    
    // otherwise revert all changes.
    x = originalX;
    image_index = originalImageIndex;
}
else
{
    // the piece is free to move so play woosh.
    audio_play_sound(sndWoosh, 10, false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="37">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle the left key from the user.

// if we aren't falling, then we can't move.
if (!isFalling)
    exit;

var xMovement = -brickSize;

// check for impact with the wall.
var obstacle = instance_place(x + xMovement, y, all);
if (obstacle == noone)
{
    // move the brick to the left.
    x += xMovement;
}
// cannot move!!!

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drops the tile down until it collides.

// we keep a sentinel value to indicate whether we should reset the time since
// last move.  This prevents the player from repeatedly pressing space to get
// infinite time.
var resetTime = false;

// Move the brick down until it collides.
while (scrCanTileFall(self))
{
    y += brickSize;
    
    // since we actually moved the tile down we should allow the time to be reset.
    resetTime = true;
}

// reset the time since last move to zero so that the user has time
// to move the tile sideways if desired.
if (resetTime)
    timeSinceLastMove = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
